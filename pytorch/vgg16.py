# -*- coding: utf-8 -*-
"""Vgg16

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1SU0YYGnmcRvPtvdL6Mv0X2p-s5jbRfH6
"""

import torch
import torch.nn as nn
import torch.nn.functional as F
import torchvision
import torchvision.transforms as transforms
import matplotlib.pyplot as plt
import numpy as np

# Device configuration
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

batch_size = 256
T=transform = transforms.Compose(
    [transforms.ToTensor(),
     transforms.Normalize((0.485, 0.456, 0.406), (0.229, 0.224, 0.225))])
## Downloading Train dataset
train = torchvision.datasets.CIFAR10('/file/',train=True,download =True,transform = T)
train = torch.utils.data.DataLoader(train,batch_size = batch_size,shuffle=True)


## Downloading Test dataset
test = torchvision.datasets.CIFAR10('/file/',train=False,download =True,transform = T)
test = torch.utils.data.DataLoader(test,batch_size = batch_size ,shuffle=True)

classes = ('plane', 'car', 'bird', 'cat', 'deer', 
           'dog', 'frog', 'horse', 'ship', 'truck')

for index,(images,labels) in enumerate(train):
  print(index,images.size(),len(labels))
  break

class Vgg16(nn.Module):
  def __init__(self):
    super(Vgg16,self).__init__()

    self.layer1 = nn.Sequential(nn.Conv2d(in_channels = 3,out_channels= 64 , kernel_size = 3 , stride = 1),
                                nn.ReLU(),
                                nn.Conv2d(in_channels = 64,out_channels= 64 , kernel_size = 3 , stride = 1),
                                nn.ReLU(),
                                nn.MaxPool2d(stride=2, kernel_size =3))
    
    self.layer2 = nn.Sequential(nn.Conv2d(in_channels = 64,out_channels= 128 , kernel_size = 3 , stride = 1),
                                nn.ReLU(),
                                nn.Conv2d(in_channels = 128 ,out_channels= 128 , kernel_size = 3 , stride = 1),
                                nn.ReLU(),
                                nn.MaxPool2d(stride=2, kernel_size =3))
    
    self.layer3 = nn.Sequential(nn.Conv2d(in_channels = 128,out_channels= 256 , kernel_size = 3 , stride = 1),
                                nn.ReLU(),
                                nn.Conv2d(in_channels = 256 ,out_channels= 256 , kernel_size = 3 , stride = 1),
                                nn.ReLU(),
                                nn.Conv2d(in_channels = 256 ,out_channels= 256 , kernel_size = 3 , stride = 1),
                                nn.ReLU(),
                                nn.MaxPool2d(stride=2, kernel_size =3))
    
    self.layer4 = nn.Sequential(nn.Conv2d(in_channels = 256,out_channels= 256 , kernel_size = 3 , stride = 1),
                                nn.ReLU(),
                                nn.Conv2d(in_channels = 256 ,out_channels= 256 , kernel_size = 3 , stride = 1),
                                nn.ReLU(),
                                nn.Conv2d(in_channels = 256 ,out_channels= 256 , kernel_size = 3 , stride = 1),
                                nn.ReLU(),
                                nn.MaxPool2d(stride=2, kernel_size =3))
    
    self.layer5 = nn.Sequential(nn.Conv2d(in_channels = 256,out_channels= 512 , kernel_size = 3 , stride = 1),
                                nn.ReLU(),
                                nn.Conv2d(in_channels = 512 ,out_channels= 512 , kernel_size = 3 , stride = 1),
                                nn.ReLU(),
                                nn.Conv2d(in_channels = 512 ,out_channels= 512 , kernel_size = 3 , stride = 1),
                                nn.ReLU(),
                                nn.MaxPool2d(stride=2, kernel_size =3))
    
    self.layer6 = nn.AdaptiveAvgPool2d((6, 6))
    self.dropout = nn.Dropout(p=0.5)

    self.fc1 = nn.Linear(512*6*6,4096)
    self.fc2 = nn.Linear(4096,4096)
    self.fc3 = nn.Linear(4096,10)

  def forward(self,x):
    x = self.layer1(x)
    x = self.layer2(x)
    x = self.layer3(x)
    x = self.layer4(x)
    x = self.layer5(x)
    x = self.dropout(x)
    x = x.view(-1,512*6*5)
    x = self.fc1(x)
    x = self.fc2(x)
    out = self.fc3(x)

    return out

model = Vgg16().to(device)
model

